<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../article-template.xsl" media="screen"?>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link rel="stylesheet" type="application/xslt+xml" href="../article-template.xsl"/>
		<title>Restricted Optionals</title>
	</head>
	<body>

<article>

<h1 id="h1-why-restricted-optionals-"><a name="Why Restricted Optionals?" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Why Restricted Optionals?</h1><p>Yesterday I wrote the first draft <a href="/lang/correctness.xhtml">describing the big picture of error handling, exceptions, validation checks</a> etc. At the end of that document I note that the language currently requires a validation check (an if statement that confirms that the enclosing request(s) will proceed without error) can often perform the same work as the enclosed requests.</p>
<p>A typical example of this is retrieving an element in a container. The act to validate that the element exists in the container can be almost identical in behaviour to the retrieval step.</p>
<p>Before we dive into that, lets quickly summarise what Optional support we currently have.</p>
<h2 id="h2-optional-member-variables"><a name="Optional Member Variables" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Optional Member Variables</h2><p>Currently the language only supports optional member variables. These exist at the class level. They allow you to describe an optional structural component. A normal member variable is declared with the <code>var</code> keyword. To declare an optional use the <code>optional</code> keyword. The syntax is not set in stone, but here’s a code snippet:</p>
<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> a</span></code></li><li class="L1"><code><span class="pln">optional b</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">constructor </span><span class="kwd">new</span></code></li><li class="L4"><code><span class="pln">    a </span><span class="pun">:=</span><span class="pln"> </span><span class="lit">42</span></code></li><li class="L5"><code><span class="kwd">end</span></code></li><li class="L6"><code></code></li><li class="L7"><code><span class="pln">query foo</span></code></li><li class="L8"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> b isAttached </span><span class="kwd">then</span></code></li><li class="L9"><code><span class="pln">        </span><span class="kwd">return</span><span class="pln"> a </span><span class="pun">*</span><span class="pln"> b</span></code></li><li class="L0"><code><span class="pln">    </span><span class="kwd">else</span><span class="pln"> </span></code></li><li class="L1"><code><span class="pln">        </span><span class="kwd">return</span><span class="pln"> a</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">end</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">command bar</span></code></li><li class="L5"><code><span class="pln">    b </span><span class="pun">:=</span><span class="pln"> </span><span class="lit">7</span></code></li><li class="L6"><code><span class="kwd">end</span></code></li></ol></pre><p>The things of interest in this example are</p>
<ul>
<li><code>b</code> is not initialised in the constructor, <code>a</code> must be initialised in the constructor.</li><li>The usage of <code>b</code> must be within a validation check <code>if b isAttached then</code>.</li></ul>
<p>This language takes heavy influence from Eiffel. And this idea is taken from there, called Void Safety (though it might also be referred to as null safety in modern languages). Many languages now have a statically enforced check on the usage of optionals.</p>
<h3 id="h3-null"><a name="Null" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Null</h3><p>Small detour, Null in older langugages was typically used to express one of three things.</p>
<ol>
<li><p><strong>Something that was uninitialised, or lazily initialised.</strong> Accidental usage of an uninitialised variable has shown to be quite the source of bugs. And while lazy initialisation is of some interest, I believe that concurrency makes this a lesser concern (if not replaced). If it truly is desired, both can most likely be modeled with the structural optional variable with some boilerplate.</p>
</li><li><p><strong>Something that was optional.</strong> This is supported in the language. <code>optional</code> is taking the place of null here.</p>
</li><li><strong>An error signal.</strong> This is related to the problem of having a validation check followed by an action that both perform the same work. We’ll discuss this more later.</li></ol>
<p>The core issue with the null concept is that it can apply to all variables, and dereferencing (accessing) a variable that is currently null is a runtime error. They can be extremely difficult to detect and debug. Such a widely affecting bug category has shown to be a serious issue.</p>
<h2 id="h2-concurrency-changes-everything"><a name="Concurrency Changes Everything" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Concurrency Changes Everything</h2><p>Concurrency is at the heart of the design of this language. Delivering a seemless, automatic concurrent programming language is priority one.</p>
<p>Unfortunately, concurrency brings some serious headaches. We’re going to lose some of the guarentees and assumptions we’ve taken for granted in our sequential programming languages.</p>
<p>The main point of contention is <strong>Late Binding</strong>. Late binding is one possible answer to the question - at what time is an identifier linked to its value? </p>
<p>There are many early and late binding stages. The switchover point between early and late is the point where the system is executing. Early is before the system is running, Late is after. The terms are related to Static and Dynamic. Early and Late are a much greater spectrum of stages, of which Static and Dynamic are but two of them.</p>
<p>In our sequential programs we’ve come to rely on early binding, e.g. Static Binding, Link Time Binding, etc. In fact I would argue that the over emphasis of Static and Dynamic is a biproduct of sequential programming. “We program in the static realm, and the system either works or it doesnt, in the dynamic realm - To fix it we go back to the static realm”</p>
<p><strong>It is extremely advantageous to have bindings as early as possible</strong> - There is zero argument from me - we should be making bindings as early as possible. There are clear benefits to tooling, analysis, and customer satisfaction when issues are found before the end-user finds them. As a language designer, I believe that choosing (juggling) the binding times of your language concepts is one of the most important design choices you’ll face. I would recommend beginning by acknowledging all the other early and late stages, and we let go of Static vs Dynamic.</p>
<h4 id="h4-late-binding-has-arrived"><a name="Late Binding Has Arrived" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Late Binding Has Arrived</h4><p>Now we’re all on board on early vs late binding. The bad news is concurrency is inherently dynamic and late bound. E.g. Run this <em>on the next available resource</em>. Whats the next available resource? We can only find out when running!</p>
<p>Even the behaviour of the system can be in flux while it is running. You could be messaging one object, and the very next message is directed to another object. Potentially with a completely different implementation and type.</p>
<p>Grappling concurrency is a talk all in its self. Hopefully this is enough for now.</p>
<p>Having a language that has late binding massively limits the knowledge, analysis, and tooling available to us. We need to be smart about what we can usefully live with, and what we can do to replace the (static) analysis we’ve come to love.</p>
<h2 id="h2-optional-results-and-method-arguments"><a name="Optional Results and Method Arguments" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Optional Results and Method Arguments</h2><p>There is a major issue to the level of guarentees we can make when we have late binding. Conceptually, <em>all</em> identifiers in a class are late bound. We have no way of gathering information <em>across</em> classes. The two crossing’s we’re interested in are the arguments to a method, and the return type of a method.</p>
<p>So this means I either add optionals, meaning I can not enforce them to be inside a validation check. Sacrificing any guarentees that a variable always holds a value (Back to the Null days).</p>
<p>Or we try something else.</p>
<h3 id="h3-arity-overloading"><a name="Arity Overloading" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Arity Overloading</h3><p>Arity overloading removes the need for optional arguments. You are <em>statically</em> declaring the set of arguments the caller is providing. And all of these values are guaranteed to be present to the callee classes method. The method identifier is still late bound (The language aims to have a type checker, and this would be bound at Integration Check time. More on that on another post!), but the argument set is not. This fits beautifully with the language which is a smalltalk derivative and has named parameters. An example:</p>
<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code><span class="pln">query foo</span><span class="pun">:</span><span class="pln"> a1 direction</span><span class="pun">:</span><span class="pln"> dir</span></code></li><li class="L1"><code><span class="pln">    </span><span class="com">//...</span></code></li><li class="L2"><code><span class="kwd">end</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">query foo</span><span class="pun">:</span><span class="pln"> a2</span></code></li><li class="L5"><code><span class="pln">    </span><span class="com">// direction is now optional.</span></code></li><li class="L6"><code><span class="pln">    </span><span class="com">// ...</span></code></li><li class="L7"><code><span class="pln">    </span><span class="com">// Or, you can define a default value for direction</span></code></li><li class="L8"><code><span class="pln">    foo</span><span class="pun">:</span><span class="pln"> a2 direction</span><span class="pun">:</span><span class="pln"> </span><span class="str">"ascending"</span></code></li><li class="L9"><code><span class="kwd">end</span></code></li><li class="L0"><code></code></li><li class="L1"><code><span class="pln">x foo</span><span class="pun">:</span><span class="pln"> </span><span class="str">"a value"</span></code></li><li class="L2"><code><span class="pln">x foo</span><span class="pun">:</span><span class="pln"> </span><span class="str">"a value"</span><span class="pln"> direction</span><span class="pun">:</span><span class="pln"> </span><span class="str">"descending"</span></code></li></ol></pre><p>I believe this is a workable solution, but no silver bullet. It has its own issues just as optional arguments, the <code>?.</code> operator etc have in their design space. Firstly, you have to duplicate a method for each optional - I suspect a simple syntax can help there. Secondly, I suspect this will increase the number of Validation Checks, potentially just another syntax issue. The if statement with its begin and ends is quite verbose, and the increase might lead to <a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming">pyramids of doom</a>. I'm aware of these potentials but feel this is a good first pass.</p>
<h3 id="h3-returning-an-optional-"><a name="Returning an Optional?" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Returning an Optional?</h3><p>Returning an optional is problematic with late binding because the caller has no way of knowing prior to getting the result if it was optional or not. We’d have to dynamically check every result to see if it was optional (back to Null again). This also raises issues with Code Contracts. What does returning an optional even mean?</p>
<p>It is my belief that returning a naked optional (Returning a structure that has optional member variables is AOK) breaks the postconditional contract of a method. If this is true, the <em>only</em> use of an optional return value is to signal an error.</p>
<p>A method either gives me a value, or it failed to give me a value.</p>
<h4 id="h4-alternatives-to-return-optional"><a name="Alternatives To Return Optional" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Alternatives To Return Optional</h4><p>If my belief is correct, this is great news. The responsibility of the a “optional return value” concept can be handled by the exception handling mechanism and Validation Checks - Which has a set of simple practises and possible analysis tools available. </p>
<p>When we look at compiler optimisations and merging Validation Checks with their enclosed actions together, we can reintroduce optional returns (more likely, null) - its an optimisation concept only.</p>
<h4 id="h4-the-forgotten-optional"><a name="The Forgotten Optional" class="reference-link"></a><span class="header-link octicon octicon-link"></span>The Forgotten Optional</h4><p>Currently optionals are class scope, what about block scoped variables? It would be trivial to add these because all the information that a given variable is optional is available. We can definitely enforce their safety. But other than using them as a temporary to hold the return value, I am unsure what they can be useful for? Ommited for now but they might appear in the future.</p>
<h2 id="h2-summary"><a name="Summary" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Summary</h2><p>So a quick summary of the juggling we’ve ended up with:</p>
<ul>
<li>Upheld late binding for our concurrency needs.</li><li>Structural Optionals, their usage statically verified.</li><li>Optional method arguments are handled with arity overloading, statically verified.</li><li>Method failure as part of the Code Contracts Model, returned optionals are completely removed.</li></ul>
<p>I hope you’ve enjoyed this post, and thanks for reading!</p>
<p>Kind regards,<br/>M ✌</p>



</article>

</body>
</html>
